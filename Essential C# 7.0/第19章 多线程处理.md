# 第 19 章 多线程处理

硬件的重要趋势：不再通过时钟速度和晶体管密度来降低计算成本。相反是利用包含多个核心的处理器来降低成本。

现在的计算会遇到各种「延迟」。就是获得结果所需要的时间。

为了保证 UI 响应迅速，同时高效利用 CPU ，标准技术是撰写多线程程序，「并行」执行多个计算。遗憾的是，多线程逻辑非常难以写好。

**<u>并行标准库</u>** ： TPL （ Task Parallel Library ，任务并行库 ）和 PLINQ 。

## 19.1 多线程处理基础

#### 初学者主题：多线程术语

* 处理器的「核心」是实际执行程序的硬件单元。同时多线程也被称为「超线程」，也就是让一个处理器表现为多个虚拟的处理器。
* 「进程」是某个程序当前正在执行的实例。每个进程中都包含一个或者多个线程。
* C# 编程的本质就是在描述控制流，一个控制流中仅有一个控制点。线程就是这个控制点。 `System.Threading` 名称空间中包含用于处理线程的 API 。
* 「单线程」程序的进程仅包含一个线程，多线程程序包含更多的线程。
* 在多线程程序中运行具有正确行为的代码，就称代码是「线程安全」的。代码的「线程处理模型」是指 **<u>代码向调用者提出一系列要求，只有满足这些要求才能保障线程安全</u>** 。
* 「任务」是可能出现高延迟的工作单元，作用是产生结果值或者希望的副作用。任务代表需要执行的工作，而线程是做工的工人。任务的意义在于其副作用，由 `Task` 类的实例表示。
* 「线程池」是多个线程的集合，通过一定的逻辑决定如何为线程分配工作。

#### 初学者主题：多线程处理的目标和实现

多线程处理主要用于两个方面：实现多任务和解决延迟。

大多数时候都是线程多核心少，为了缓解这个矛盾，操作系统通过称为「时间分片」的机制来模拟多个线程并发运行。 **<u>操作系统以极快的速度在线程之间来回切换，给人留下所有线程都在同步执行的错觉</u>** 。

处理器执行一个线程的时间周期称为「时间片」或者「量子」。在某个核心上更改执行线程的行为称为「上下文切换」。

一个多线程进程所包含的每个线程都能「不中断」的一起运行。

无论是真正的多核并行运行，还是使用「时间分片」技术来模拟并行运行，我们说一起进行的两个操作是「并发」的。实现这种并发操作需要以异步的方式来调用，被调用操作的执行和完成都独立于调用它的控制流。「并行编程」是指 **<u>将一个问题分解成较小的部分，「异步」发起对每一部分的处理，最终使它们全部都并发执行</u>** 。

#### 初学者主题：性能问题

上下文切换有代价： **<u>必须将处理器当前的状态保存到内存，还必须加载与新线程关联的状态</u>** 。如果线程太多，切换开销就会显著的影响性能。

如果一个处理器由两个线程共享，时间分片将在一个线程上执行几十万次操作，再切换到另一个线程，如此往复。

> 设计规范：
>
> * 不要以为多线程必然会让代码更快。
> * 要在通过多线程来加快解决处理器受限问题时谨慎衡量性能。

#### 初学者主题：线程处理问题

根本原因是单线程中的假设在多线程中不成立了。问题包括原子性，竞态条件，复杂的内存模型和死锁。

* 大多数操作都不是原子性的：原子操作要么尚未开始，要么已经完成。
* 竞态条件所造成的不确定性：操作系统会在它认为合适的任何事件在任何两个线程之间切换上下文。结果就是当两个线程访问同一个对象时，无法预测那个线程“竞争胜出”并且抢先运行。
* 内存模型的复杂性；
* 锁定造成死锁；

> 设计规范：
>
> * 不要无根据的以为普通代码中的原子性操作在多线程代码中也是原子性的；
> * 不要以为所有线程看到的都是一致的共享内存；
> * 要确保同时拥有多个锁的代码总是以相同的顺序获取它们。
> * 避免所有竞态条件，程序行为不能受操作系统调度线程的方式的影响。

## 19.2 使用 `System.Threading`

### 19.2.1 使用 `System.Threading.Thread` 进行异步操作

这个类的实例代表程序中的一个「控制点」。可以将线程想象成一名工作者，它独立的按照你的程序指令工作。

下面的代码中，独立控制点由并发运行的一个 `Thread` 对象表示。 **<u>线程需要知道它在启动时应当运行什么代码，所以它的构造函数要获得一个委托，这个委托指向了一个需要执行的函数</u>** 。

本例是将方法组 `DoWork` 转换成相应的委托类型 `ThreadStart` 。然后调用 `Start()` 启动线程。新线程运行时，主线程先在控制台上打印 1000 个字符，然后调用分支线程的 `Join` 方法告诉主线程这个工作线程需要等待完成：

```C#
/* 代码清单 19.1 使用 System.Threading.Thread 启动一个方法 */

using System;
using System.Threading;

public class Program
{
    public static void Main(string[] args)
    {
        ThreadStart delegatedFunction = DoWork;
        Thread testThread = new Thread(delegatedFunction);
        testThread.Start();
        for (int i = 0; i < 1000; ++i) {
            Console.Write("+");
        }
        testTread.Join();
    }
    
    public static void DoWork()
    {
        for (int i = 0; i < 1000; ++i) {
            Console.Write("-");
        }
    }
}
```

代码为了在不同线程的上下文中运行，需要 `ThreadStart` 和 `ParameterizedThreadStart` 类型的委托来标识要执行的代码，这两个标准库类型都在 `System.Threading` 命名空间；

**<u>一个方法实际上可以直接传递给线程构造函数</u>** 。

调用 `Thread.Start()` 告诉操作系统开始并发执行一个新线程。然后主线程中的控制立即返回，开始执行 `Main` 方法中的代码，两个线程独立运行，不会等待对方，直到调用 `Join` 函数。

### 19.2.2 线程管理

* `Join()` : 可以通过调用 `Join` 使一个线程等待另一个线程。它告诉操作系统暂停执行当前的线程，直到另一个线程终止。 `Join` 方法的重载版本获取一个 `int` 或者一个 `TimeSpan` 作为参数，指定最多等待多长时间，过期不候。
* `IsBackGround` ： **<u>新线程默认为「前台」线程。操作系统将进程的所有前台线程完成之后终止进程</u>** 。将这个属性设定为 `true` ，从而将这个线程标记为「后台」线程，也就是说，即使被标记的线程仍然在运行，操作系统也能关闭进程。
* `Priority` ： 每个线程都关联了优先级，可以将这个属性设定为预先定义的枚举值： `Lowest, BlowNormal, Normal, AboveNormal, Highest` 。操作系统倾向于将时间分片调拨给高优先级线程。但是容易引发「线程饥饿」。
* `ThreadState` ： 可用 `Boolean` 属性 `IsAlive` 了解一个线程是否还活着。还是已经完成了所有的工作。更全面的线程状态可以通过 `ThreadState` 属性访问。

### 19.2.3 生产代码不要让线程进入睡眠

静态 `Thread.Sleep(毫秒/TimeSpan)` 方法 **<u>使当前线程进入睡眠——其实就是告诉操作系统指定时间内不要为当前线程调拨任何时间片</u>** 。

但是这个函数有个问题，一般来说让线程进入睡眠是为了和其他线程同步。当开发者指定线程睡眠 120 毫秒时，操作系统会「至少」让这个线程睡眠 120 毫秒。因为时间片调度的关系，不太可能将时间片在其结束睡眠的第一时间进行调拨。故， **<u>不要将 `Thread.Sleep()` 作为高精度计时器</u>** 。

线程睡眠是不好的编程实践，不因为睡眠的线程是不会运行任何代码的。

> 设计规范：不要在生产代码中引入 `Thread.Sleep()` 。

### 19.2.4 生产代码中不要中断线程

`Thread` 对象的成员函数 `Abort()` （ .Net Core 中这个方法不可用 ）一旦执行，就会尝试销毁线程。它会导致「运行时」在线程中抛出 `ThreadAbortException` 异常。

> 设计规范：避免在生产代码中中断线程，因为可能发生不可预测的结果，使程序不稳定。

### 19.2.5 线程池处理

线程是昂贵的资源，并且在线程之间的切换不是没有代价的。而且通过时间分片来模拟两个工作并行，可能比一个接一个运行还要慢。

为了缓解这种情况， BCL 提供了线程池。开发人员并不会直接分配线程，而是告诉线程池想要执行什么工作。工作完成之后，线程不是直接被销毁，而是回到线程池中，从而节省了当更多工作来临时还要分配新线程的开销。

```C#
/* 代码清单 19.2 使用 ThreadPool 而不是显式实例化线程 */

using System;
using System.Threading;

public class Program
{
    public const int Repetition = 1000;
    
    public static void Main(string[] args)
    {
        ThreadPool.QueueUserWorkItem(DoWork, '+');
        ...
    }
}
```

如果有多个不同的工作异步执行，线程池能在单处理器和多处理器计算机上获得更好地执行效率。效率是通过重用线程来获得。

但是一旦用完池中的所有线程，正在排队的工作就必须延期执行。

不同于能直接操作的 `Thread` 和 `Task` 对象，线程池不会为你提供对工作线程的引用，所以无法直接管理线程。

> 设计规范：
>
> * 要用线程池向处理器受限任务高效的分配处理器事件。
> * 避免将吃中的工作者线程分配给 I/O 首先或者长时间运行的任务。

## 19.3 异步任务

多线程编程的复杂性来源：

* 监视异步操作的状态，知道它何时完成；
* 线程池；
* 避免死锁；
* 为不同的操作提供原子性并且同步数据访问；

### 19.3.1 从 `Thread` 到 `Task`

任务是对象，其中封装了以异步方式执行的工作。委托也是一个封装了代码的对象，但是区别在于，委托是同步的，而任务是异步的。 **<u>执行委托，当前的线程的控制点会立即转移到委托的代码。除非委托结束，否则控制不会返回调用者。相反，启动任务，控制几乎立即返回到调用者，无论任务要执行多少工作</u>** 。任务通常在另一个线程上异步执行。

**<u>简单来说，任务将委托从同步执行模式转换为异步</u>** 。

### 19.3.2 理解异步任务

如何知道任务于何时完成？怎么获得结果？如果有的话。

启动任务将从线程池获取一个新线程，创建第二个「控制点」，并且在那个线程上执行委托。

```C#
/* 代码清单 19.3 调用异步任务 */

using System;
using System.Threading.Tasks;

public class Program
{
    public const int Repetition = 1000;
    
    public static void Main(string[] args)
    {
        Task task = Task.Run(
        	() => {
                ...
            }
        );
        
        for (int i = 0; i < Repetition; ++i) {
            ...
        }
        
        task.Wait(); /* Wait until the task completes */
    }
}
```

需要运行的代码由传给 `Task.Run()` 方法的委托来定义。一旦调用 `Task.Run()` 作为实参传递的函数几乎里克开始运行。这称为「热任务」。相反，需要显式触发开始工作地任务称为冷任务。

调用 `Wait()` 将强迫主线程等待分配给任务的所有工作完成。相当于调用 `Join()` 。

但是假如一个方法需要返回结果呢？这时可以使用 `Task<T>` 类型来运行一个方法。 **<u>异步执行具有返回值的方法，可从一个线程轮询它，看它是否完成，完成就获得结果</u>** 。

```C#
/* 代码清单 19.4 轮询一个 Task<T> */

using System;
using System.Threading.Tasks;

public class Program
{
    public static void Main(string[] args)
    {
        Task<string> stringTask = new Task<string>.Run(
        	() => { PiCalculator.Calculate(100); }
        );
        foreach (char busySymbol in Utility.BusySymbols()) {
            if (stringTask.IsCompleted) {
            	Console.Write(NewLine);
                break;
            }
            Console.Write(busySymbol);
        }
        ...
    }
}
```

* 读取 `Result` 属性自动造成当前线程阻塞，直到结果可用；
* 任务完成后， `IsCompleted` 属性被设定为 `true` 。更加详细的状态可访问属性 `Status` 来获得。
* 任务 Id 属性的值来唯一的标识任务。静态 `Task.CurrentId` 属性返回当前正在执行的 `Task` 对象标识符。

### 19.3.3 任务延续

```C#
/* 代码清单 19.5 调用 Task.ContinueWith() */

using System;
using System.Threading.Tasks;

namespace PlayGround
{
    public class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("Before...");
            Task taskA = Task.Run(
                () => { Console.WriteLine("Task A is Running..."); }
            );
            Task taskB = taskA.ContinueWith(
                antecedent => { Console.WriteLine("Task B is Running..."); }
            );
            Task taskC = taskA.ContinueWith(
                antecedent => { Console.WriteLine("Task C is Running..."); }
            );
            Task.WaitAll(taskB, taskC);
            Console.WriteLine("All Works Done.");
        }
    }
}
```

