# 第5章 方法和参数

## 5.1 方法的调用

方法 **组合一系列语句以执行特定的操作或者计算特定的结果** 。

```C#
// 代码清单 5.1 语句组合成为方法
public class LineCount
{
    public static void Main(string[] args)
    {
        DisplayHelpText();
        string files = GetFiles();
        int lineCount = CountLines(files);
        DisplayLineCount(lineCount);
    }
}
```

> **设计规范** ：要为方法名使用动词或者动词短语。

方法总是和类型关联。类型将相关的方法分成一组。

方法通过 **实参** 接收数据，实参由 方法的参数 或者 **形参** 定义。 **参数** 是 **<u>调用者用于向被调用的方法传递数据的变量</u>** 。

```C#
// 代码清单 5.2 简单方法调用
public class HeyYou
{
    public static void Main(string[] args)
    {
        System.Console.WriteLine("Hey You!");
        System.Console.Write("Enter your first name: ");
        string firstName = System.Console.ReadLine();
        System.Console.Write("Enter your last name: ");
        string lastName = System.Console.ReadLine();
        System.Console.WriteLine($"Your full name: { firstName } { lastName }");
    }
}
```

**方法调用** 由 **方法名称** 和 **实参列表** 构成。完全限定的方法名称包括：**命名空间** 、**类型名称** 和 **方法名称** ，每个部分使用 **点运算符（ `.` ）** 分隔。

### 5.1.1 命名空间

命名空间是一种分类机制，用于分组功能相关的所有类型。主要用命名空间按功能领域组织类型，以便查找和理解这些类型。并且还有助于防范类型名称冲突。

假定要调用的方法和发出调用的方法在同一个命名空间，就没必要指定命名空间。

> **设计规范** ：
> * 要为命名空间使用 `PascalCase` 大小写。
> * 考虑组织源代码文件目录结构以匹配命名空间层次结构。

### 5.1.2 类型名称

调用静态方法时，如目标方法和调用者不在同一个类型或者基类中，就需要添加 **类型名称限定符** 。

### 5.1.3 作用域

一个事物的 **作用域** 是 **<u>可用非限定名称引用它的那个区域</u>** 。

### 5.1.4 方法名称

### 5.1.5 形参和实参

方法可以获取任意数量的形参，每个形参都具有特定的数据类型。调用者为形参提供的值称为实参，每个实参都要和一个形参对应。

### 5.1.6 方法返回值

可以利用返回值将调用方法所产生的结果返回给调用者。

```C#
// 代码清单 5.3 将方法返回值作为实参传给另一个方法调用
public class Program
{
    public static void Main(string[] args)
    {
        System.Console.Write("Enter your first name: ");
        System.Console.WriteLine("Hello {0}!", System.Console.ReadLine());
    }
}
```

### 5.1.7 对比语句和方法调用

**语句通常包含一个或者多个表达式** 。方法调用构成了语句的不同部分。

> **设计规范** ：通常开发者应当侧重于代码的可读性，而不是在写更短的代码上耗费心机。

## 5.2 方法的声明

```C#
// 代码清单 5.4 声明方法
using System;

public class IntroducingMethods
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Hey You!");
        string firstName = GetUserInput("Enter your first name: ");
        string lastName = GetUserInput("Enter your last name: ");
        string fullName = GetFullName(firstName, lastName);
        string initials = GetInitials(firstName, lastName);
        DisplayGreeting(fullName, initials);
    }

    public static string GetUserInput(string prompt)
    {
        Console.Write(prompt);
        return Console.ReadLine();
    }

    public static string GetFullName(string firstName, string lastName)
        => $"{ firstName } { lastName }";

    public static string GetInitials(string firstName, string lastName)
        => $"{ firstName[0] }. { lastName[0] }";

    public static void DisplayGreeting(string fullName, string initials)
    {
        Console.WriteLine($"Hello, { fullName }, your initials is { initials }");
    }
}

// Hey You!
// Enter your first name: Inigo
// Enter your last name: Montoya
// Hello, Inigo Montoya, your initials is I. M
```

C# 不支持全局方法，一切都必须在一个类型声明中。

将一组语句转移到一个方法当中，而不是将其全部暴露在 `Main` 方法里面，本质上是一种重构形式。

### 5.2.1 参数声明

可以在方法声明的圆括号中添加 **参数列表** 。列表中的每个参数都包含 **参数类型** 和 **参数名称** ，并且以逗号运算符进行分隔。

大多数参数的行为和命名规范与局部变量一致。所以参数名采用 `camelCase` 大小写形式。并且方法内部不能出现和形参同名的局部变量。

> **设计规范** ：要为参数名使用 `camelCase` 大小写。

### 5.2.2 方法返回类型声明

`return` 关键字后面的表达式必须兼容方法的返回值类型。

如果方法有返回类型，那么其主体必须有 **不可到达的结束点** 。也就是 **方法不能在不返回任何值的情况下碰到大括号而自然结束** 。

```C#
// 代码清单 5.5 方法中间的 return 语句
public class Program
{
    public static bool MyMethod()
    {
        string command = ObtainCommand();
        switch (command) {
            case "quit" :
                return false;
                // 这里只要有 return 语句进行返回
                // 就不需要 break 语句了
            default :
                return true;
        }
    }
}
```

* 如果 `return` 语句之后有不可到达的语句，编译器会发出警告。
* 尽量确定单一的退出位置，而不是在方法的多个代码路径中散布 `return` 语句。
* `void` 调用只能当作语句来使用。

从 C# 7.0 开始，多个值可以通过 C# 元组语法打包成元组进行返回：

```C#
using System;

public class Program
{
    public static void Main(string[] args)
    {
        (string firstName, string lastName) fullName = GetName();
        Console.WriteLine($"Hello, { fullName.firstName }. { fullName.lastName }!");
    }

    public static string GetUserInput(string prompt)
    {
        Console.Write(prompt);
        return Console.ReadLine();
    }

    public static (string, string) GetName()
    {
        string firstName = GetUserInput("Enter your first name: ");
        string lastName = GetUserInput("Enter your last name: ");
        return (firstName, lastName);
    } 
}
```

### 5.2.3 表达式主体方法

C# 6.0 引入了 **表达式主体方法** ，允许使用表达式代替完整方法主体：

```C#
public static string GetFullName(string firstName, string lastName)
    => $"{ fistName } { lastName }";
```

`=>` 操作符的结果数据类型必须和方法的返回类型匹配。

和 C++ 不同， C# 从来不将实现和声明分开，这样就不需要在两个位置维护冗余的声明。

**命名空间** 是分类和分组相关类型的一种机制。

## 5.3 `using` 指令

```C#
// 代码清单 5.7 using 指令的例子

// The using directive imports all types from
// the specified namespace into the entire file
using System;

public class HelloWorld
{
    public static void Main(string[] args)
    {
        Console.WriteLine("Hello World");
    }
}
```

然而需要注意的是，`using` 指令不导入任何 **嵌套命名空间** 中的类型。也就是说，如果 `System` 空间中还有类似 `IO` 这样的命名空间，其中的类型是不会被导入进来的。如果需要使用，那么就必须显式的进行声明：

```C#
using System;
using System.IO;
```

在 **文件顶部** 和 **命名空间顶部** 使用 `using` 指令的区别在于：**后者的 `using` 指令只在声明的命名空间内有效** 。

### 5.3.1 `using static` 指令

该指令允许将命名空间和类型名称全部省略，只需要写静态成员名称：

```C#
// 代码清单 5.9 using static 指令

using static System.Console;

public class Program
{
    public static void Main(string[] args)
    {
        string msg = ReadLine();
        WriteLine($"Message: { msg }.");        
    }
}
```

然而这种方式可能会造成潜在的命名冲突。如果两个成员具有相同的签名，调用它们时会产生歧义，造成编译错误。

### 5.3.2 使用别名

防止命名冲突的一个方法是设置别名：

```C#
// 代码清单 5.10 声明类型别名

using System;
using System.Threading;
using CountDownTimer = System.Timers.Timer; // 指定别名

public class HelloWorld
{
    public static void Main(string[] args)
    {
        CountDownTimer timer;
        // ...
    }
}
```

```C#
// 代码清单 5.11 声明同名的类型别名

using System;
using System.Threading;

// Declare alias Timer to refer to System.Timers.Timer
// to avoid code ambiguity with System.Threading.Timer
using Timer = System.Timers.Timer

public class Program
{
    public static void Main(string[] args)
    {
        Timer systemTimer;
        // 这里的 Timer 是 System.Timers.Timer
        // 如果想要使用 System.Threading.Timer
        // 那就必须完全限定：
        System.Threading.Timer threadTimer;
    }
}
```

## 5.4 `Main()` 的返回值和参数

Runtime 通过一个 `string` 数组参数将命令行参数传递给 `Main` 。想要获取参数，访问数组就可以了：

```C#
using System;
using System.Net;
using static System.Console;

public class Program
{
    public static void Main(string[] args)
    {
        string fileName = null;
        string url = null;
        if (args.Length != 2) {
            WriteLine("ERROR: URL and file name must be specified.");
        } else {
            url = args[0];
            fileName = args[1];
        }
        if (url != null && fileName != null) {
            WebClient webClient = new WebClient();
            webClient.DownloadFile(url, fileName);
        } else {
            WriteLine("Usage: Download.exe <URL> <FileName>");
        }
    }
}
```

返回值对于 `Main` 声明来说是可选的。但如果有返回值，程序就可以将 **状态码** 返回给调用者（比如脚本或者批处理文件）。根据约定，**非零返回值代表出错** 。

#### 调用栈和调用点

每次调用新方法，Runtime 都会创建一个 **栈帧** 或者 **活动帧** ，其中包含的内容涉及传给 **新调用** 的实参、局部变量以及返回时该从哪里恢复等等。这样形成的一系列栈帧称为 **调用栈** 。调用栈的大小根据调用方法的数量变大变小。我们使用 **栈展开** 描述从调用栈中删除栈帧的过程。栈展开的顺序通常与方法调用的顺序相反。方法调用完毕，控制会返回调用点，也就是最初发出调用的位置。

## 5.5 高级方法参数

### 5.5.1 值参数
