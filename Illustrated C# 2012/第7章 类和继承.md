# 第7章 类和继承

## 7.1 类继承

可以使用一个已经存在的类作为新类的基础。已存在的类称为 **基类** ，新类称为 **派生类** 。

派生类成员的组成如下：

* 本身声明中的成员。
* 基类的成员。

要声明一个派生类，需要在类名后加入 **基类规格说明：由冒号和后面跟着的用作基类的类名组成** 。 **派生类被描述为直接继承自列出的基类** 。

> 派生类不能删除它所继承的任何成员。

```C#
using System;

public class Father
{
    int Wealth = 10000;
    int House = 3;
    
    public void ShowFortune()
    {
        Console.WriteLine("*********Father**********");
        Console.WriteLine("* The Wealth: {0}", Wealth);
        Console.WriteLine("* The House: {0}", House);
        Console.WriteLine("*************************");
    }
}

public class Son : Father
{
    new public void ShowFortune() // 隐藏了Father中的同名方法
    {
        Console.WriteLine("***********Son***********");
        base.ShowFortune(); // 显式的调用基类中的方法
        Console.WriteLine("*************************");
    }
}

public class Program
{
    public static void Main()
    {
        Father ftr = new Father();
        ftr.ShowFortune();
        Son sn = new Son();
        sn.ShowFortune();
    }
}

// output:
// *********Father********** 这是Father的对象调用的方法
// * The Wealth: 10000
// * The House: 3
// *************************
// ***********Son*********** 这里明显就是Son的对象调用的同名方法
// *********Father**********
// * The Wealth: 10000
// * The House: 3
// *************************
// *************************
```

## 7.2 访问继承的成员

基类的成员可以在派生类中无缝访问。

## 7.3 所有类都派生自`object`类

**除了特殊的类`object`，所有的类都是派生类，即使它们没有规格说明**。类`object`是唯一的非派生类，因为它是继承层次结构的基础。

关于类继承的其他重要内容如下：

* 一个类声明的基类规格说明中只能有一个单独的类。这称为单继承。
* 虽然类只能直接继承一个积累，但是继承的层次没有限制。

基类和派生类只是相对的说法。

## 7.4 屏蔽基类的成员

**<u>派生类可以使用与基类成员名称相同的成员来隐藏基类成员</u>**。

在派生类中隐藏基类成员的一些要点如下：

* **要隐藏一个继承的数据成员，只需要声明一个新的相同类型的成员，并且使用相同的名称即可**。
* **通过在派生类中声明新的带有相同签名的函数成员，可以隐藏继承的函数成员**。
* 如果要让编译器知道你在故意隐藏继承的成员，使用`new`修饰符。否则编译器会发出警告。
* 可以隐藏静态成员。

例子的话就是7.1的那个例子。

## 7.5 基类访问

如果派生类必须完全访问被隐藏的继承成员，可以使用 **<u>基类访问表达式</u>** 访问隐藏的继承成员。

**基类访问表达式由关键字 `base` 使用点运算符（`.`）调用成员名称**：

```C#
// BaseField是被隐藏的基类字段
Console.WriteLine("{0}", base.BaseField);
```

例子还是7.1节里面的例子。

## 7.6 使用基类的引用

派生类的实例由基类的实例加上派生类新增的成员组成。派生类的引用指向整个类对象，包括基类部分。

**如果有一个派生类对象的引用，就可以获取该对象基类部分的引用**（使用类型转换运算符把该引用转换为基类类型）。类型转换运算符放在对象引用的前面，由圆括号括起的要被转换成的类名组成。

```C#
Derived derived = new Derived(); // 创建一个对象
Base based = (Base)derived; // 转换引用
```

以上的程序中，`derived`这个引用对对象内的所有字段和方法可见。`based`这个引用仅仅对派生类对象中属于基类的部分可见。

**<u>派生类的引用可以看到完整的派生类对象，而基类的引用只能看到派生类对象中基类的部分</u>**。

```C#
using System;

public class BaseClass
{
    public void PrintInformation()
    {
        Console.WriteLine("Here is method from Base.");
    }
}

public class DerivedClass : BaseClass
{
    new public void PrintInformation()
    {
        Console.WriteLine("Here is method from Derived.");
    }
}

public class Program
{
    public static void Main()
    {
        DerivedClass DrvObj = new DerivedClass();
        BaseClass ClsObj = (BaseClass)DrvObj;
        ClsObj.PrintInformation();
        DrvObj.PrintInformation();
    }
}

// Output:
// Here is method from Base.
// Here is method from Derived.
```

### 7.6.1 虚方法和覆写方法

默认情况下，当使用基类引用访问派生类对象时，得到的是基类的成员。**虚方法可以使基类的引用访问到达派生类内**。

**可以使用基类引用调用派生类的方法**，需要满足下面的条件：

* **派生类的方法和基类的方法有相同的签名和返回类型**。
* **基类的方法使用`virtual`标注**。
* **派生类的方法使用`override`标注**。

```C#
public class BaseClass // 基类
{
    virtual public void Print() { ... }
}

public class DerivedClass // 派生类
{
    override public void Print() { ... }
}
```

**当使用基类引用调用`Print`方法时，方法调用被传递到派生类并执行**，因为：

* **基类中的方法被标记为`virtual`**。
* **在派生类中有匹配的`override`方法**。

```C#
using System;

public class BaseClass
{
    public int Width { set; get; }
    public int Height { set; get; }

    public virtual void PrintInformation()
    {
        Console.WriteLine("************************************");
        Console.WriteLine("* Height from Base: {0}", this.Height);
        Console.WriteLine("* Width from Base: {0}", this.Width);
        Console.WriteLine("************************************");
    }
}

public class DerivedClass : BaseClass
{
    public int Weight { set; get; }

    public override void PrintInformation()
    {
        Console.WriteLine("************************************");
        Console.WriteLine("* Height from Base: {0}", Height);
        Console.WriteLine("* Width from Base: {0}", Width);
        Console.WriteLine("* Weight from Derived: {0}", Weight);
        Console.WriteLine("************************************");
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        DerivedClass de = new DerivedClass();
        de.Weight = 10;
        de.Width = 50;
        de.Height = 1000;
        de.PrintInformation();
        BaseClass ba = (BaseClass)de;
        ba.PrintInformation();
    }
}

// output:
// ************************************
// * Height from Base: 1000
// * Width from Base: 50
// * Weight from Derived: 10
// ************************************
// ************************************
// * Height from Base: 1000
// * Width from Base: 50
// * Weight from Derived: 10
// ************************************
```

其他关于`virtual`和`override`修饰符的重要信息：

* **覆写和被覆写的方法必须有相同的访问权限**。
* **不能覆写`static`方法或者非虚方法**。
* **方法、属性、索引器，以及成员类型事件，都可以被声明为`virtual`和`override`**。

### 7.6.2 覆写标记为`override`的方法

覆写方法可以在继承的任何层次出现。

* **当使用对象基类部分的引用调用一个覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为`override`的方法的最高派生版本。也就是和基类引用关联的那个派生类引用的层次**。
* 如果在更高的派生级别有该方法的其他声明，但是没有被`override`标记，那么它们也不会被调用。

```C#
using System;

public class BaseClass
{
    virtual public void PrintInformation()
    {
        Console.WriteLine("Here is method from Base.");
    }
}

public class DerivedClassOne : BaseClass
{
    override public void PrintInformation()
    {
        Console.WriteLine("Here is method from Derived One Level.");
    }
}

public class DerivedClassTwo : DerivedClassOne
{
    new public void PrintInformation() // 原因就是因为这里使用了new
    // [virtual - override]的追溯体系里面不能把手伸到new修饰的函数上
    {
        Console.WriteLine("Here is method from Derived Two Level.");
    }
}

public class Program
{
    public static void Main()
    {
        DerivedClassTwo DrvObj = new DerivedClassTwo(); // 这里是Two
        BaseClass ClsObj = (BaseClass)DrvObj;
        ClsObj.PrintInformation();
    }
}

// Output:
// Here is method from Derived One Level. 但这里最高追溯到One
```

### 7.6.3 覆盖其他类型成员

```C#
// 覆盖属性：
using System;

public class BaseClass
{
    virtual public string ClassName { get; set; }

    virtual public void PrintInformation()
    {
        Console.WriteLine("Here is method from Base.");
    }
}

public class DerivedClassOne : BaseClass
{
    // private string s = "ClassOne";

    override public string ClassName
    {
        set;// { s = value; } 如果这里初始化，那么就能追溯到初始化的内容
        get;// { return s; } 否则就只能追溯到一个空字符串
    }

    override public void PrintInformation()
    {
        Console.WriteLine("Here is method from Derived One Level.");
    }
}

public class DerivedClassTwo : DerivedClassOne
{
    new public string ClassName { get; set; }

    new public void PrintInformation()
    // 如果这里用new修饰，那么就算创建的是Two的引用，追溯也只能到ClassOne
    // 如果这里使用override修饰，那么就可以直接追溯到这里，显示ClassTWo
    {
        Console.WriteLine("Here is method from Derived Two Level.");
    }
}

public class Program
{
    public static void Main()
    {
        DerivedClassTwo DrvObj = new DerivedClassTwo(); // 这里是Two的对象引用
        DrvObj.ClassName = "ClassTwo"; // 设置的是ClassTwo
        BaseClass ClsObj = (BaseClass)DrvObj;
        Console.WriteLine(ClsObj.ClassName);
    }
}
```

## 7.7 构造函数的执行

**<u>派生类对象有一部分就是基类对象</u>**。

* 要创建对象的基类部分，需要隐式调用基类的构造函数作为创建对象过程的一部分。
* 继承层次链中的每个类在执行它自己的构造函数体之前执行它的基类构造函数。

创建一个对象完成的第一件事是初始化对象的所有成员。在此之后，调用基类的构造函数，然后才执行该类自己的构造函数。也就**先构造基类部分，再构造自己的部分**。

警告：**<u>在构造函数中使用虚函数是极其不推荐的</u>**。

### 7.7.1 构造函数初始化语句

**默认情况下，在构造对象时，将调用基类的无参数构造函数**。但是构造函数可以重载，所以基类可能有一个以上的构造函数。**如果希望派生类使用一个指定的基类构造函数，必须在构造函数初始化语句中指定它**。

有两种形式的构造函数初始化语句：

* <u>**使用关键字`base`并指明使用哪一个`基类`构造函数**</u>。
* **使用关键字`this`并指明应该使用`当前类`的哪一个构造函数**。

```C#
using System;

public class Base
{
    public int x;
    public int y;
    public Base() : this(10, 100) {  } // 2无参数构造函数再委托给有两个参数的构造函数
    public Base(int x, int y) // 3实际上执行这个构造函数
    {
        this.x = x;
        this.y = y;
    }
}

public class Derived : Base
{
	public int z;
	
	public Derived(int z) : base() { this.z = z; } // 1先执行基类的无参数的构造函数
	// 4最后执行这个构造函数的函数体
	
	public void PrintInformation()
	{
		Console.WriteLine("*************************************");
		Console.WriteLine("* The x from Base is: {0}.", base.x);
		Console.WriteLine("* The y from Base is: {0}.", base.y);
		Console.WriteLine("* The z from Derived is: {0}.", this.z);
		Console.WriteLine("*************************************");
	}
}

public class Program
{
    public static void Main()
    {
        Derived obj = new Derived(-1000);
        obj.PrintInformation();
    }
}

// Output:
// *************************************
// * The x from Base is: 10.
// * The y from Base is: 100.
// * The z from Derived is: -1000.
// *************************************
```

这个语法有个很有用的一种情况，就是将很多构造函数需要的代码封装到一个构造函数里，然后各个构造函数再委托这个函数进行对象的构造。

当一个构造函数无法完全初始化一个对象的时候，就必须将这个构造函数设置为`private`，以禁止这个函数从外部进行调用。

### 7.7.2 类访问修饰符

**类的可访问性有两个级别：`public`和`internal`**。

* **标记为public的类可以被系统内任何程序集中的代码访问**。要使一个类对其他程序集可见，使用`public`访问修饰符：`public class MyClass { ... }`。
* **标记为`internal`的类只能被它自己所在的程序集内的类看到**。
    * 这是默认的可访问级别，所以，除非在类的声明中显式的指定`public`，程序集外部的代码不能访问该类。
    * 可以使用`internal`访问修饰符显式的声明一个类为内部的：`internal class MyClass { ... }`。

## 7.8 程序集间的继承

要从不同程序集中定义的基类派生类，必须具备以下条件：

* 基类必须被声明为`public`这样才能从它所在的程序集外部访问它。
* 必须在VS工程中的References节点中添加对包含该基类的程序集的引用。

## 7.9 成员访问修饰符

* 必须对每个成员指定访问级别。如果不进行显式指定，它的隐式访问级别为`private`。
* 成员不能比它所在的类拥有更高的可访问性。

### 7.9.1 访问成员的区域

```C#
public class MyClass
{
    public int val1;
    private int val2;
    protected int val3;
    internal int val4;
    protected internal int val5;
}
```

另一个类能够访问这些成员取决于该类的两个特征：

* 是否派生自`MyClass`类。
* 是否和`MyClass`在同一程序集。

### 7.9.2 公有成员的可访问性

**`public`访问级别是限制性最少的**。

### 7.9.3 私有成员的可访问性

* `private`类成员只能被它自己的类的成员访问。它不能被其他类成员访问，包括继承它的类。
* `private`成员能被嵌套在它的类中的类（嵌套类）成员访问。

### 7.9.4 受保护成员的可访问性

`protected`访问级别如同`private`访问级别，但是它**允许派生自该类的类访问该成员**。即使是程序集外部继承该类的类也能访问该成员。

### 7.9.5 内部成员的可访问性

**标记为`internal`的成员对程序集内部的所有类可见，但对程序集外部的类不可见**。

### 7.9.6 受保护内部成员的可访问性

**对所有继承该类的类以及所有程序集内部的类可见**。也就是说这两个修饰符的叠加逻辑是“或”。

### 7.9.7 成员访问修饰符小结

* `private` - 只在类的内部可访问；
* `internal` - 对该程序内所有类可访问；
* `protected` - 对所有继承该类的类可访问；
* `protected internal` - 对所有继承该类的类以及程序集内声明的类可访问；
* `public` - 对任何类可访问；

## 7.10 抽象成员

**设计为被覆写的函数成员**。特征如下：

* **必须是一个函数成员**。字段和常量不能成为抽象成员。
* 必须用`abstract`修饰符标记。
* 不能有实现代码块。丑相成员的代码用分号表示。

```C#
public abstract void PrintStuff(string s); // 抽象成员函数
public abstract int MyProperty { set; get; } // 抽象属性
```

**抽象成员只能在抽象类中声明**。一共有4个类型的成员可以声明为抽象的：**方法、属性、事件、索引**。

* 尽管抽象成员必须在派生类中用相应的成员覆写，但不能把`virtual`修饰符附加到`abstract`修饰符。
* 类似虚成员，**派生类中的抽象成员的实现必须指定`override`修饰符**。

#### 虚成员和抽象成员的区别

* 虚成员有实现体，能被覆写，使用`override`即可。
* 抽象成员没有实现体（被分号取代），必须被覆写，也是使用`override`。

## 7.11 抽象类

**设计为专门用来继承的类。抽象类只能做其他类的基类**。

* 不能创建抽象类的实例。
* 抽象类使用`abstract`修饰符。

```C#
abstract class AbsClass { ... }
```

* **抽象类可以包含抽象成员和非抽象成员**。抽象类的成员可以是抽象成员和普通带实现成员的任意组合。

* 抽象了自己可以派生自另一个抽象类。

    ```C#
    abstract class AbsClassOne { ... }
    abstract class AbsClassTwo : AbsClassOne { ... }
    ```

* **任何派生自抽象类的类必须使用`override`关键字实现该类所有的抽象成员，除非派生类自己也是抽象类**。

### 7.11.1 抽象类和抽象方法的例子

```C#
using System;

public abstract class AbsClass // 不能生成实例
{
    abstract public void PrintInformation();
}

public class ClassOne : AbsClass
{
    override public void PrintInformation()
    {
        Console.WriteLine("Here is ClassOne.");
    }
}

public class ClassTwo : AbsClass
{
    override public void PrintInformation()
    {
        Console.WriteLine("Here is ClassTwo.");
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        ClassOne clsone = new ClassOne();
        ClassTwo clstwo = new ClassTwo();
        clsone.PrintInformation();
        clstwo.PrintInformation();
    }
}

// output:
// Here is ClassOne.
// Here is ClassTwo.
```

### 7.11.2 抽象类的另一个例子

## 7.12 密封类

* 密封类只能被看作是独立的类，它不能被用作基类。否则会出现编译错误。
* 密封类使用`sealed`修饰符标注。

```C#
sealed class MyClass { ... }
```

## 7.13 静态类

静态类中所有的成员都是静态的。静态类用于存放不受实例数据影响的数据和函数。

* 类本身标记为`static`。
* 类的所有成员必须是静态的。
* 类可以有一个静态构造函数，但不能构造实例。
* 静态类是密封的。

```C#
public static class MyClass { ... }
```

## 7.14 扩展方法

## 7.15 命名约定

